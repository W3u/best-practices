## 什么是代理

## 为什么需要代理

## 静态代理

### 静态代理的局限性

- 代码重复与维护困难： 对于每一个需要代理的目标类，都需要创建一个对应的代理类去实现相同的接口。随着目标类数量的增加，代理类的数量也随之增加，这不仅导致代码量大幅增加，而且一旦接口发生变化，所有的代理类都需要同步修改，维护成本高。
- 灵活性不足： 静态代理的逻辑在编译时期就已经固定，运行时无法动态改变。这意味着如果需要改变代理的行为或者添加新的代理功能，就必须修改代理类的源代码并重新编译部署。
- 扩展性受限： 静态代理往往针对特定的接口或类实现，这限制了其适用范围。如果需要为不同接口或具有不同行为的类创建代理，就需要编写多个不同的代理类，这在面对复杂的系统时难以应对多变的需求。
- 类型耦合： 静态代理类直接依赖于被代理类的实现，这种紧密的耦合关系降低了系统的灵活性和可测试性。修改被代理类的实现细节可能会影响到代理类，反之亦然。
- 资源消耗： 如果系统中有大量相似功能的类需要代理，每个类都对应一个代理类，这将占用较多的内存资源，尤其是在大型项目中，这种资源消耗更为显著。

综上所述，静态代理在实现简单代理逻辑时是有效的，但对于复杂系统或需要灵活配置的场景，其局限性就显得尤为突出，这也是动态代理被广泛采用的原因之一。动态代理通过在运行时动态生成代理类，提供了更高的灵活性和扩展性。

## 动态代理

Q：动态生成的代理类 会继承 java.lang.reflect.Proxy类 吗？
当使用java.lang.reflect.Proxy类的newProxyInstance()方法创建动态代理时，Java会生成一个内部的代理类，这个代理类继承自Proxy类，并实现了被代理的接口。Proxy类是Java提供的一个基础类，它提供了代理对象的实现框架，包括调用处理器（InvocationHandler）的调用逻辑。
代理类的结构如下：
- 它是一个匿名的类，通常在运行时由JVM动态生成。
- 这个匿名类继承自Proxy。
- 它实现所有被代理接口的方法，这些方法通常会调用InvocationHandler的invoke()方法来执行实际的业务逻辑。


### 动态代理的局限性

尽管动态代理在Java编程中提供了极大的灵活性和便利性，但它也有一些局限性：
- 仅限于接口： Java标准库中的动态代理（基于java.lang.reflect.Proxy）要求目标对象必须实现一个或多个接口。这意味着它不能直接代理一个没有实现接口的类，这有时会限制其应用场景。
- 性能开销： 动态代理在运行时创建代理类和调用处理器（InvocationHandler）会带来一定的性能开销，虽然这种开销在大多数现代应用中是可以接受的，但在性能敏感的场景下，如高频交易系统，可能会成为一个考虑因素。
- 调试困难： 由于动态代理类是在运行时自动生成的，它们不在源代码中显式定义，这使得在出现问题时进行调试和跟踪变得更加困难。特别是当代理逻辑复杂时，理解代理行为可能需要更深入地分析字节码或依赖于IDE的高级调试功能。
- 字节码生成的复杂性： 如果需要更复杂的代理逻辑，比如需要代理没有实现接口的类，开发者可能需要转向第三方库（如CGLIB、ASM等），这些库允许基于类的代理，但这通常涉及到更底层的字节码操作，增加了学习曲线和潜在的错误空间。
- 限制了继承行为： 因为动态代理基于接口实现，它不支持对类的继承特性进行代理，这意味着无法直接通过动态代理来扩展类的功能，除非通过其他方式模拟继承行为。
- 安全性考虑： 动态生成代码可能会引起安全问题，尤其是在处理不可信数据或在受限环境中（如沙盒环境）运行时。虽然这不是动态代理特有的问题，但在设计时需要考虑到这一点。

总的来说，虽然动态代理提供了一种强大的设计模式来增强代码的灵活性和解耦能力，但在特定情况下，开发者需要权衡其带来的便利与潜在的局限性。



## 代理对象生成后，是何时替换掉真实业务对象的？

## spring aop 自动代理 是如何实现的

Spring AOP 的自动代理功能主要通过实现org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator或其子类来完成。下面是一个简化的流程说明：
* 配置扫描和自动代理： 
  * 在Spring配置中，通常会启用AOP并配置自动代理，如使用<aop:aspectj-autoproxy />标签或Java配置类的@EnableAspectJAutoProxy注解，这将激活一个特定的自动代理创建器。
* Bean后处理器：
  * AbstractAutoProxyCreator是Spring的一个Bean后处理器（BeanPostProcessor），它会在容器初始化每个Bean实例时进行拦截处理。
* 决定是否需要生成代理：
  * 当Bean后处理器处理某个Bean时，它会调用shouldSkip()方法判断该Bean是否需要被AOP代理增强。这个判断基于用户定义的规则，例如是否有切面应用于该Bean。
  应用通知与生成代理信息：
  如果判定需要生成代理，则根据已注册的Advisor和Aspect来确定针对该Bean的方法调用应该应用哪些通知（Advice）。
* 创建代理对象：
  * 使用内部逻辑检查目标类是否实现了接口，进而选择合适的代理机制：如果目标类实现了至少一个接口，则使用JDK动态代理；否则，使用CGLIB库创建子类代理。
* 构建代理工厂：
  * 通过ProxyFactory或其他相关的类来创建代理工厂，将目标对象、通知列表以及其他代理配置（如代理类型）封装在内。
* 生成并返回代理对象：
  * 最后，由代理工厂根据配置生成实际的代理对象，并将其返回给Spring容器，替代原本的目标Bean引用。
* 方法调用与拦截执行：
  * 当客户端代码通过代理对象调用方法时，代理对象会根据预先设定的通知逻辑，在方法调用前后执行相应的增强操作。

总结来说，Spring AOP 自动代理的实现依赖于Spring容器的生命周期管理机制以及动态代理技术，它在运行时分析并动态地为符合条件的Bean生成代理对象，从而实现面向切面编程的功能。